/**
 * Apache License Version 2.0, January 2004 http://www.apache.org/licenses/
 *
 * <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 * <p>1. Definitions.
 *
 * <p>"License" shall mean the terms and conditions for use, reproduction, and distribution as
 * defined by Sections 1 through 9 of this document.
 *
 * <p>"Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is
 * granting the License.
 *
 * <p>"Legal Entity" shall mean the union of the acting entity and all other entities that control,
 * are controlled by, or are under common control with that entity. For the purposes of this
 * definition, "control" means (i) the power, direct or indirect, to cause the direction or
 * management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent
 * (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.
 *
 * <p>"You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by
 * this License.
 *
 * <p>"Source" form shall mean the preferred form for making modifications, including but not
 * limited to software source code, documentation source, and configuration files.
 *
 * <p>"Object" form shall mean any form resulting from mechanical transformation or translation of a
 * Source form, including but not limited to compiled object code, generated documentation, and
 * conversions to other media types.
 *
 * <p>"Work" shall mean the work of authorship, whether in Source or Object form, made available
 * under the License, as indicated by a copyright notice that is included in or attached to the work
 * (an example is provided in the Appendix below).
 *
 * <p>"Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or
 * derived from) the Work and for which the editorial revisions, annotations, elaborations, or other
 * modifications represent, as a whole, an original work of authorship. For the purposes of this
 * License, Derivative Works shall not include works that remain separable from, or merely link (or
 * bind by name) to the interfaces of, the Work and Derivative Works thereof.
 *
 * <p>"Contribution" shall mean any work of authorship, including the original version of the Work
 * and any modifications or additions to that Work or Derivative Works thereof, that is
 * intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an
 * individual or Legal Entity authorized to submit on behalf of the copyright owner. For the
 * purposes of this definition, "submitted" means any form of electronic, verbal, or written
 * communication sent to the Licensor or its representatives, including but not limited to
 * communication on electronic mailing lists, source code control systems, and issue tracking
 * systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and
 * improving the Work, but excluding communication that is conspicuously marked or otherwise
 * designated in writing by the copyright owner as "Not a Contribution."
 *
 * <p>"Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a
 * Contribution has been received by Licensor and subsequently incorporated within the Work.
 *
 * <p>2. Grant of Copyright License. Subject to the terms and conditions of this License, each
 * Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
 * irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display,
 * publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or
 * Object form.
 *
 * <p>3. Grant of Patent License. Subject to the terms and conditions of this License, each
 * Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
 * irrevocable (except as stated in this section) patent license to make, have made, use, offer to
 * sell, sell, import, and otherwise transfer the Work, where such license applies only to those
 * patent claims licensable by such Contributor that are necessarily infringed by their
 * Contribution(s) alone or by combination of their Contribution(s) with the Work to which such
 * Contribution(s) was submitted. If You institute patent litigation against any entity (including a
 * cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated
 * within the Work constitutes direct or contributory patent infringement, then any patent licenses
 * granted to You under this License for that Work shall terminate as of the date such litigation is
 * filed.
 *
 * <p>4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works
 * thereof in any medium, with or without modifications, and in Source or Object form, provided that
 * You meet the following conditions:
 *
 * <p>(a) You must give any other recipients of the Work or Derivative Works a copy of this License;
 * and
 *
 * <p>(b) You must cause any modified files to carry prominent notices stating that You changed the
 * files; and
 *
 * <p>(c) You must retain, in the Source form of any Derivative Works that You distribute, all
 * copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding
 * those notices that do not pertain to any part of the Derivative Works; and
 *
 * <p>(d) If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative
 * Works that You distribute must include a readable copy of the attribution notices contained
 * within such NOTICE file, excluding those notices that do not pertain to any part of the
 * Derivative Works, in at least one of the following places: within a NOTICE text file distributed
 * as part of the Derivative Works; within the Source form or documentation, if provided along with
 * the Derivative Works; or, within a display generated by the Derivative Works, if and wherever
 * such third-party notices normally appear. The contents of the NOTICE file are for informational
 * purposes only and do not modify the License. You may add Your own attribution notices within
 * Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the
 * Work, provided that such additional attribution notices cannot be construed as modifying the
 * License.
 *
 * <p>You may add Your own copyright statement to Your modifications and may provide additional or
 * different license terms and conditions for use, reproduction, or distribution of Your
 * modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and
 * distribution of the Work otherwise complies with the conditions stated in this License.
 *
 * <p>5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution
 * intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms
 * and conditions of this License, without any additional terms or conditions. Notwithstanding the
 * above, nothing herein shall supersede or modify the terms of any separate license agreement you
 * may have executed with Licensor regarding such Contributions.
 *
 * <p>6. Trademarks. This License does not grant permission to use the trade names, trademarks,
 * service marks, or product names of the Licensor, except as required for reasonable and customary
 * use in describing the origin of the Work and reproducing the content of the NOTICE file.
 *
 * <p>7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor
 * provides the Work (and each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation,
 * any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 * PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or
 * redistributing the Work and assume any risks associated with Your exercise of permissions under
 * this License.
 *
 * <p>8. Limitation of Liability. In no event and under no legal theory, whether in tort (including
 * negligence), contract, or otherwise, unless required by applicable law (such as deliberate and
 * grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for
 * damages, including any direct, indirect, special, incidental, or consequential damages of any
 * character arising as a result of this License or out of the use or inability to use the Work
 * (including but not limited to damages for loss of goodwill, work stoppage, computer failure or
 * malfunction, or any and all other commercial damages or losses), even if such Contributor has
 * been advised of the possibility of such damages.
 *
 * <p>9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative
 * Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty,
 * indemnity, or other liability obligations and/or rights consistent with this License. However, in
 * accepting such obligations, You may act only on Your own behalf and on Your sole responsibility,
 * not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each
 * Contributor harmless for any liability incurred by, or claims asserted against, such Contributor
 * by reason of your accepting any such warranty or additional liability.
 *
 * <p>END OF TERMS AND CONDITIONS
 *
 * <p>APPENDIX: How to apply the Apache License to your work.
 *
 * <p>To apply the Apache License to your work, attach the following boilerplate notice, with the
 * fields enclosed by brackets "[]" replaced with your own identifying information. (Don't include
 * the brackets!) The text should be enclosed in the appropriate comment syntax for the file format.
 * We also recommend that a file or class name and description of purpose be included on the same
 * "printed page" as the copyright notice for easier identification within third-party archives.
 *
 * <p>Copyright 2024 Rhynia
 *
 * <p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of the License at
 *
 * <p>http://www.apache.org/licenses/LICENSE-2.0
 *
 * <p>Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.rhynia.ochelper.component;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.rhynia.ochelper.database.DatabaseUpdater;
import com.rhynia.ochelper.util.CommandPackEnum;
import com.rhynia.ochelper.util.LuaScriptFactory;
import com.rhynia.ochelper.util.Utilities;
import com.rhynia.ochelper.var.element.connection.*;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.commons.lang3.tuple.Triple;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * @author Rhynia
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class DataProcessor {

    // region Construction Variables
    private final DatabaseUpdater du;
    private final LuaScriptFactory ls;
    private final List<AeCpu> cpus = new ArrayList<>();
    private final List<OcComponent> components = new ArrayList<>();
    private final List<OcComponentMethod> componentMethods = new ArrayList<>();
    private final List<MsSet> msSets = new ArrayList<>();
    private final Map<Integer, String> methodMap = new HashMap<>();
    private final Map<Integer, OcComponentDoc> docMap = new HashMap<>();
    private final Map<Integer, String> sensorMap = new HashMap<>();
    private final Lock lock = new ReentrantLock();
    private final Condition cCpuFetch = lock.newCondition();
    private final Condition cCpuDetailFetch = lock.newCondition();
    private final Condition cCraftableFetch = lock.newCondition();
    private final Condition cCraftStateFetch = lock.newCondition();
    private final Condition cCancelCraft = lock.newCondition();
    private final Condition cComponentFetch = lock.newCondition();
    private final Condition cMethodFetch = lock.newCondition();
    private final Condition cDocFetch = lock.newCondition();
    private final Condition cTPSFetch = lock.newCondition();
    private final Condition cGtSensorFetch = lock.newCondition();
    private final Condition cCustomFetch = lock.newCondition();
    private final AeReportItemObj dummy = AeReportItemObj.getDummy();

    @SuppressWarnings("unchecked")
    private final List<AeReportItemObj>[] cpuDetailList = new ArrayList[3];

    private final AtomicBoolean requestCraftingState = new AtomicBoolean();
    private final AtomicBoolean requestCancelState = new AtomicBoolean();
    private final AtomicBoolean requestDocState = new AtomicBoolean();
    private final AtomicBoolean requestCpuDetailState = new AtomicBoolean();
    private final AtomicBoolean requestSensorState = new AtomicBoolean();
    private final AtomicInteger docIndex = new AtomicInteger();
    private final AtomicInteger cpuDetailIndex = new AtomicInteger();
    private final AtomicInteger sensorIndex = new AtomicInteger();
    private List<AeCraftObj> craftableItems = new ArrayList<>();
    private AeReportItemObj cpuDetailFinal = dummy;
    private String customReturn = "";

    // endregion

    // region AE Storage methods
    private void updateAeItemData(List<AeReportItemObj> list) {

        var opt = Optional.ofNullable(list);

        opt.ifPresent(
                l -> {
                    var d = l.stream().peek(Utilities::updateLocalMap).toList();
                    long begin = System.currentTimeMillis();
                    du.updateItemDatabase(d);
                    long end = System.currentTimeMillis();
                    System.out.printf(
                            "Received item report form OC, size: %d, using %d ms.%n",
                            l.size(), end - begin);
                });
    }

    private void updateAeFluidData(List<AeReportFluidObj> list) {

        var opt = Optional.ofNullable(list);

        opt.ifPresent(
                l -> {
                    long begin = System.currentTimeMillis();
                    du.updateFluidDatabase(l);
                    long end = System.currentTimeMillis();
                    System.out.printf(
                            "Received fluid report form OC, size: %d, using %d ms.%n",
                            l.size(), end - begin);
                });
    }

    // endregion

    // region AE CPU Information methods
    public List<AeCpu> requestAeCpuInfo() {

        log.info("Requested CPU info.");
        boolean timeout = false;
        lock.lock();
        try {
            ls.injectMission(CommandPackEnum.AE_GET_CPU_INFO.getPack());
            timeout = !cCpuFetch.await(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Method interrupted.");
        } finally {
            lock.unlock();
            if (timeout) {
                log.error("Timeout in requesting.");
            }
        }

        if (!cpus.isEmpty()) {
            log.info("AE CPU info successfully fetched.");
            return cpus;
        } else {
            log.error("Fetched no cpus.");
            return List.of(AeCpu.of(-1, "NO_CPU", 0, "0", true));
        }
    }

    public Pair<List<AeReportItemObj>[], AeReportItemObj> requestAeCpuDetail(int cpuid) {

        log.info("Requesting CPU detail.");
        cpuDetailFinal = dummy;
        cpuDetailIndex.set(0);
        var cpl =
                List.of(
                        CommandPackEnum.AE_GET_CPU_DETAIL_ACTIVE.ofParams(cpuid),
                        CommandPackEnum.AE_GET_CPU_DETAIL_STORE.ofParams(cpuid),
                        CommandPackEnum.AE_GET_CPU_DETAIL_PENDING.ofParams(cpuid),
                        CommandPackEnum.AE_GET_CPU_DETAIL_FINAL.ofParams(cpuid));
        boolean timeout = false;
        requestCpuDetailState.set(true);
        lock.lock();
        try {
            ls.injectMission(cpl);
            timeout = !cCpuDetailFetch.await(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Method interrupted.");
        } finally {
            lock.unlock();
            if (timeout) {
                log.error("Timeout in requesting.");
            }
        }
        return Pair.of(cpuDetailList, cpuDetailFinal);
    }

    // endregion

    // region AE Craft methods
    public List<AeCraftObj> requestAeCraftList() {

        log.info("Requesting AE craft list.");
        boolean timeout = false;
        lock.lock();
        try {
            ls.injectMission(CommandPackEnum.AE_GET_CRAFTABLE.getPack());
            timeout = !cCraftableFetch.await(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Method interrupted.");
        } finally {
            lock.unlock();
            if (timeout) {
                log.error("Timeout in requesting.");
            }
        }

        if (!craftableItems.isEmpty()) {
            log.info("AE craft list successfully fetched.");
            return craftableItems;
        } else {
            log.error("Fetched no crafts.");
            return List.of(AeCraftObj.getDummy());
        }
    }

    public boolean requestAeCraft(String name, int meta, int amount) {

        log.info("Processor received request.");
        boolean timeout = false;
        lock.lock();
        try {
            ls.injectMission(CommandPackEnum.AE_DO_CRAFT.ofParams(name, meta, amount));
            timeout = !cCraftStateFetch.await(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Method interrupted.");
        } finally {
            lock.unlock();
            if (timeout) {
                log.error("Timeout in requesting.");
            }
        }

        return requestCraftingState.get();
    }

    public boolean cancelCrafting(int id) {

        log.info("Attempt to cancel crafting task on {}.", id);
        boolean timeout = false;
        lock.lock();
        try {
            ls.injectMission(CommandPackEnum.AE_DO_CPU_CANCEL.ofParams(id));
            timeout = !cCancelCraft.await(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Method interrupted.");
        } finally {
            lock.unlock();
            if (timeout) {
                log.error("Timeout in requesting.");
            }
        }

        return requestCancelState.get();
    }

    // endregion

    // region Components information methods
    public List<OcComponent> requestComponentList() {

        log.info("Requesting component list.");
        boolean timeout = false;
        lock.lock();
        try {
            ls.injectMission(CommandPackEnum.OC_GET_COMPONENT.getPack());
            timeout = !cComponentFetch.await(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Method interrupted.");
        } finally {
            lock.unlock();
            if (timeout) {
                log.error("Timeout in requesting.");
            }
        }

        if (!components.isEmpty()) {
            log.info("Components successfully fetched.");
            return components;
        } else {
            log.error("Fetch no available components.");
            return List.of(OcComponent.of("Fetched NOTHING!", "NULL"));
        }
    }

    public Map<Integer, OcComponentDoc> requestComponentDetail(String address) {

        // Cleanup doc fetch cache
        resetDocFetch();

        // First find if methods exist
        log.info("Start requesting component detail.");
        boolean timeout = false;
        lock.lock();
        try {
            ls.injectMission(CommandPackEnum.OC_GET_COMPONENT_METHOD.ofParams(address));
            timeout = !cMethodFetch.await(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Method interrupted.");
        } finally {
            lock.unlock();
            if (timeout) {
                log.error("Timeout in requesting.");
            }
        }

        // Components like keyboard have no methods, return NULL
        if (componentMethods.isEmpty()) {
            log.error("Fetch no available methods, stop requesting for docs.");
            return Map.of(0, OcComponentDoc.of("NULL", "This component has no methods."));
        }

        // Then find methods with documents
        log.info("Method list fetched, start requesting docs.");
        var documentCommands = new ArrayList<CommandPack>();
        var pack = CommandPackEnum.OC_GET_COMPONENT_DOC;
        componentMethods.stream()
                .sorted(Comparator.comparing(OcComponentMethod::getMethod))
                .forEach(
                        (method) -> {
                            methodMap.put(docIndex.get(), method.getMethod());
                            documentCommands.add(
                                    pack.ofSuffixAndParams(
                                            String.valueOf(docIndex.getAndIncrement()),
                                            address,
                                            method.getMethod()));
                        });

        lock.lock();
        try {
            ls.injectMission(documentCommands);
            requestDocState.set(true);
            timeout = !cDocFetch.await(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Method interrupted.", e);
        } finally {
            lock.unlock();
            if (timeout) {
                log.error("Timeout in requesting.");
            }
        }

        if (!docMap.isEmpty()) {
            log.info("Methods & Docs successfully fetched.");
            return docMap;
        } else {
            log.error("Fetched no available docs.");
            return Map.of(0, OcComponentDoc.of("NULL", "Fetched nothing at all."));
        }
    }

    private void resetDocFetch() {
        docIndex.set(0);
        docMap.clear();
        methodMap.clear();
    }

    // endregion

    // region Gregtech methods

    public List<Triple<String, String, String>> requestGtMachineSensor() {

        // Reset cache
        resetSensorFetch();

        // Get GT Component list
        log.info("Requesting All GT Sensor information, fetching component list first.");
        var requests = new ArrayList<CommandPack>();
        var gtComponentAddressMap =
                requestComponentList().stream()
                        .filter(component -> "gt_machine".equals(component.getName()))
                        .map(OcComponent::getAddress)
                        .collect(
                                Collectors.toMap(
                                        i -> sensorIndex.getAndIncrement(), Function.identity()));

        if (gtComponentAddressMap.isEmpty()) {
            log.error("There isn't any GT component.");
            return List.of(Triple.of("NULL", "?", "NULL"));
        }

        var cp = CommandPackEnum.GT_GET_SENSOR;
        gtComponentAddressMap.forEach(
                (k, v) -> requests.add(cp.ofSuffixAndParams(String.valueOf(k), v)));

        boolean timeout = false;
        lock.lock();
        try {
            ls.injectMission(requests);
            requestSensorState.set(true);
            timeout = !cGtSensorFetch.await(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Method interrupted.", e);
        } finally {
            lock.unlock();
            if (timeout) {
                log.error("Timeout in requesting.");
            }
        }

        var tmpList = new ArrayList<Triple<String, String, String>>();
        sensorMap.forEach(
                (k, v) -> {
                    String address = gtComponentAddressMap.get(k);
                    tmpList.add(Triple.of(address, Utilities.getAddressAlias(address), v));
                });

        return tmpList;
    }

    private void resetSensorFetch() {
        sensorIndex.set(0);
        sensorMap.clear();
    }

    // endregion

    // region Utility methods
    public String executeCustomCommand(String command) {

        log.info("Requested executing a custom command: {}", command);
        var cc = CommandPackEnum.CUSTOM.ofCommand(command);
        boolean timeout = false;
        lock.lock();
        try {
            ls.injectMission(cc);
            timeout = !cCustomFetch.await(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Method interrupted.", e);
        } finally {
            lock.unlock();
            if (timeout) {
                log.error("Timeout in requesting.");
            }
        }
        return customReturn;
    }

    public List<MsSet> requestTpsReport() {

        log.info("Requested TPS.");
        boolean timeout = false;
        lock.lock();
        try {
            ls.injectMission(CommandPackEnum.TPS_ALL_TICK_TIMES.getPack());
            timeout = !cTPSFetch.await(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("Method interrupted.", e);
        } finally {
            lock.unlock();
            if (timeout) {
                log.error("Timeout in fetching.");
            }
        }

        if (!msSets.isEmpty()) {
            return msSets;
        } else {
            return List.of(MsSet.of(0, 1D));
        }
    }

    // endregion

    // region Processing values methods
    @SuppressWarnings("unchecked")
    private Map<String, String> readResult(String raw) {
        if (raw == null || raw.isEmpty() || "[]".equals(raw)) {
            return Map.of("NULL", "NULL");
        }
        Map<String, String> result = Map.of("NULL", "NULL");
        try {
            ObjectMapper mapper =
                    new ObjectMapper()
                            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
            result = mapper.readValue(raw, Map.class);
        } catch (Exception e) {
            log.error("Exception in decoding: ", e);
        }
        return result;
    }

    @SuppressWarnings("unchecked")
    private void processResult(Map<String, String> map) {
        ObjectMapper mapper =
                new ObjectMapper()
                        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        map.forEach(
                (k, v) -> {
                    log.debug("Received respond key -> {}", k);
                    log.debug("Received respond body -> {}", v);
                    boolean error = "ERROR".equals(v) || "\"ERROR\"".equals(v);
                    if (error) {
                        log.error("Received ERROR report in action {}.", k);
                    }
                    if (k.startsWith("OC_GET_COMPONENT_DOC_")) {
                        int index = Integer.parseInt(k.substring(21));
                        docMap.put(
                                index,
                                OcComponentDoc.of(methodMap.get(index), Utilities.stripQuotes(v)));
                        log.debug("Received component doc of index {}.", index);
                    } else if (k.startsWith("GT_GET_SENSOR_")) {
                        int index = Integer.parseInt(k.substring(14));
                        try {
                            List<String> tmp = mapper.readValue(v, new TypeReference<>() {});
                            String formatted =
                                    tmp.stream()
                                            .filter(StringUtils::isNotEmpty)
                                            .map(Utilities::colorMinecraftToHtml)
                                            .map(s -> s + "<br/>")
                                            .reduce(String::concat)
                                            .orElse("Null");
                            sensorMap.put(index, formatted);
                        } catch (Exception e) {
                            log.error("Error in mapping sensor info, original was {}.", v);
                            sensorMap.put(index, "Error");
                        }
                    } else {
                        switch (k) {
                            case "AE_GET_ITEM" -> {
                                try {
                                    List<AeReportItemObj> temp =
                                            mapper.readValue(v, new TypeReference<>() {});
                                    updateAeItemData(temp);
                                } catch (Exception e) {
                                    log.error("Map fail in {} :", k, e);
                                }
                            }
                            case "AE_GET_FLUID" -> {
                                try {
                                    List<AeReportFluidObj> temp =
                                            mapper.readValue(v, new TypeReference<>() {});
                                    updateAeFluidData(temp);
                                } catch (Exception e) {
                                    log.error("Map fail in {} :", k, e);
                                }
                            }
                            case "AE_GET_CPU_INFO" -> {
                                try {
                                    cpus.clear();
                                    List<AeCpu> temp =
                                            mapper.readValue(v, new TypeReference<>() {});
                                    cpus.addAll(temp);
                                    lock.lock();
                                    try {
                                        cCpuFetch.signal();
                                    } finally {
                                        lock.unlock();
                                    }
                                } catch (Exception e) {
                                    log.error("Map fail in {} :", k, e);
                                }
                            }
                            case "AE_GET_CPU_DETAIL_ACTIVE" -> {
                                if (Objects.equals(v, "[]")) {
                                    cpuDetailList[0] = new ArrayList<>();
                                    cpuDetailList[0].add(dummy);
                                } else {
                                    try {
                                        List<AeReportItemObj> temp =
                                                mapper.readValue(v, new TypeReference<>() {});
                                        cpuDetailList[0] = temp;
                                    } catch (Exception e) {
                                        log.error("Map fail in {} :", k, e);
                                    }
                                }
                                cpuDetailIndex.incrementAndGet();
                            }
                            case "AE_GET_CPU_DETAIL_STORE" -> {
                                if (Objects.equals(v, "[]")) {
                                    cpuDetailList[1] = new ArrayList<>();
                                    cpuDetailList[1].add(dummy);
                                } else {
                                    try {
                                        List<AeReportItemObj> temp =
                                                mapper.readValue(v, new TypeReference<>() {});
                                        cpuDetailList[1] = temp;
                                    } catch (Exception e) {
                                        log.error("Map fail in {} :", k, e);
                                    }
                                }
                                cpuDetailIndex.incrementAndGet();
                            }
                            case "AE_GET_CPU_DETAIL_PENDING" -> {
                                if (Objects.equals(v, "[]")) {
                                    cpuDetailList[2] = new ArrayList<>();
                                    cpuDetailList[2].add(dummy);
                                } else {
                                    try {
                                        List<AeReportItemObj> temp =
                                                mapper.readValue(v, new TypeReference<>() {});
                                        cpuDetailList[2] = temp;
                                    } catch (Exception e) {
                                        log.error("Map fail in {} :", k, e);
                                    }
                                }
                                cpuDetailIndex.incrementAndGet();
                            }
                            case "AE_GET_CPU_DETAIL_FINAL" -> {
                                if (Objects.equals(v, "null") || Objects.equals(v, "[]")) {
                                    cpuDetailFinal = dummy;
                                } else {
                                    try {
                                        cpuDetailFinal =
                                                mapper.readValue(v, new TypeReference<>() {});
                                    } catch (Exception e) {
                                        log.error("Map fail in {} :", k, e);
                                    }
                                }
                                cpuDetailIndex.incrementAndGet();
                            }
                            case "AE_GET_CRAFTABLE" -> {
                                try {
                                    craftableItems = mapper.readValue(v, new TypeReference<>() {});
                                    lock.lock();
                                    try {
                                        cCraftableFetch.signal();
                                    } finally {
                                        lock.unlock();
                                    }
                                } catch (Exception e) {
                                    log.error("Map fail in {} :", k, e);
                                }
                            }
                            case "AE_DO_CRAFT" -> {
                                if ("\"DONE\"".equals(v)) {
                                    requestCraftingState.set(true);
                                    log.info("Crafting task succeeded.");
                                } else {
                                    log.info("Crafting task failed.");
                                    requestCraftingState.set(false);
                                }
                                try {
                                    lock.lock();
                                    try {
                                        cCraftStateFetch.signal();
                                    } finally {
                                        lock.unlock();
                                    }
                                } catch (Exception e) {
                                    log.error("Map fail in {} :", k, e);
                                }
                            }
                            case "AE_DO_CPU_CANCEL" -> {
                                if ("\"DONE\"".equals(v)) {
                                    requestCancelState.set(true);
                                    log.info("Crafting cancelling succeeded.");
                                } else {
                                    log.error("Crafting cancelling failed.");
                                    requestCancelState.set(false);
                                }
                                try {
                                    lock.lock();
                                    try {
                                        cCancelCraft.signal();
                                    } finally {
                                        lock.unlock();
                                    }
                                } catch (Exception e) {
                                    log.error("Map fail in {} :", k, e);
                                }
                            }
                            case "OC_GET_COMPONENT" -> {
                                try {
                                    Map<String, String> temp = mapper.readValue(v, Map.class);
                                    components.clear();
                                    temp.forEach(
                                            (address, name) ->
                                                    components.add(OcComponent.of(address, name)));
                                    lock.lock();
                                    try {
                                        cComponentFetch.signal();
                                    } finally {
                                        lock.unlock();
                                    }
                                    log.debug("Received component info: " + temp);
                                } catch (Exception e) {
                                    log.error("Map fail in {} :", k, e);
                                }
                            }
                            case "OC_GET_COMPONENT_METHOD" -> {
                                try {
                                    if (!Objects.equals(v, "[]")) {
                                        Map<String, Boolean> temp = mapper.readValue(v, Map.class);
                                        componentMethods.clear();
                                        temp.forEach(
                                                (method, valid) ->
                                                        componentMethods.add(
                                                                OcComponentMethod.of(
                                                                        method, valid)));
                                        log.debug("Received method info: {}", temp);
                                    } else {
                                        log.info("Requested a component that has no methods.");
                                        componentMethods.clear();
                                    }
                                    lock.lock();
                                    try {
                                        cMethodFetch.signal();
                                    } finally {
                                        lock.unlock();
                                    }
                                } catch (Exception e) {
                                    log.error("Map fail in {} :", k, e);
                                }
                            }
                            case "GT_GET_ENERGY" -> log.info(v);
                            case "GT_GET_ENERGY_WIRELESS" -> {
                                if (!error) {
                                    try {
                                        List<String> tmp =
                                                mapper.readValue(v, new TypeReference<>() {});
                                        var tmp1 =
                                                tmp.stream()
                                                        .filter(
                                                                s ->
                                                                        s.startsWith(
                                                                                "Total wireless EU"))
                                                        .map(s -> s.substring(21))
                                                        .findFirst()
                                                        .orElse("0");
                                        System.out.printf(
                                                "Fetched wireless energy information of (%s).%n",
                                                tmp1);
                                        var tmp2 =
                                                new BigDecimal(tmp1.replaceAll(",", ""))
                                                        .stripTrailingZeros();
                                        du.updateEnergyDatabase(tmp2);
                                    } catch (Exception e) {
                                        log.error("Map fail in {} :", k, e);
                                    }
                                } else {
                                    log.error(
                                            "Caught error in GT_GET_ENERGY_WIRELESS, energy station connection may not"
                                                    + " set properly.");
                                }
                            }
                            case "TPS_ALL_TICK_TIMES" -> {
                                try {
                                    Map<String, Double> temp = mapper.readValue(v, Map.class);
                                    msSets.clear();
                                    temp.forEach(
                                            (dim, mspt) -> MsSet.of(Integer.parseInt(dim), mspt));
                                    log.info("Received TPS report of {} dims.", temp.size());
                                    lock.lock();
                                    try {
                                        cTPSFetch.signal();
                                    } finally {
                                        lock.unlock();
                                    }
                                } catch (Exception e) {
                                    log.error("Map fail in {} :", k, e);
                                }
                            }
                            case "CUSTOM" -> {
                                log.info("Received CUSTOM pack respond.");
                                customReturn = v;
                                lock.lock();
                                try {
                                    cCustomFetch.signal();
                                } finally {
                                    lock.unlock();
                                }
                            }
                            case "NULL" -> log.debug("Received null respond from OC.");
                            case "ERROR" ->
                                    log.error(
                                            "Encountered ERROR key package, seems exception in lua scripts assembling.");
                            default -> {
                                log.error("Encountered an unexpected key in command return: {}", k);
                                log.error("The content of result is: {}", v);
                            }
                        }
                    }
                });
        postProcessCheck();
    }

    /**
     * At present this method contains signal for
     *
     * <p>1.Document fetching
     *
     * <p>2.CPU information fetching process
     *
     * <p>3.Sensor information fetching
     */
    private void postProcessCheck() {
        if (requestDocState.get() && docMap.size() >= docIndex.get()) {
            log.info("Doc fetch complete.");
            lock.lock();
            try {
                cDocFetch.signal();
            } finally {
                lock.unlock();
                requestDocState.set(false);
            }
            return;
        }
        if (requestCpuDetailState.get() && cpuDetailIndex.get() >= 4) {
            log.info("CPU detail fetch complete.");
            lock.lock();
            try {
                cCpuDetailFetch.signal();
            } finally {
                lock.unlock();
                requestCpuDetailState.set(false);
                cpuDetailIndex.set(0);
            }
        }
        if (requestSensorState.get() && sensorMap.size() >= sensorIndex.get()) {
            log.info("Sensor fetch complete.");
            lock.lock();
            try {
                cGtSensorFetch.signal();
            } finally {
                lock.unlock();
                requestSensorState.set(false);
                sensorIndex.set(0);
            }
        }
    }

    // endregion

    // region Entrance
    public void readAndProcessResult(String raw) {
        processResult(readResult(raw));
    }
    // endregion
}
